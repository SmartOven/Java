# Многопоточность в Java
## Создание потока (нити)
За потоки (нити) в Java отвечает класс `Thread`. Создать новую нить можно двумя способами - реализовать интерфейс 
`Runnable` или унаследоваться от класса `Thread`.  
Для создания новой нити через `Runnable` необходимо:
1) Создать объект класса `Thread`, 
2) Передать в него объект (интерфейса `Runnable`), метод `run()` которого надо выполнить
3) Вызвать у созданного объекта `Thread` метод `start`

Для создания новой нити через `Thread` необходимо:
1) Унаследовать класс от класса `Thread` и переопределить в нем `run()`
2) Создать объект такого класса
3) Вызвать у созданного объекта метод `start()`

## Ожидание завершения выполнения работы потока (нити)
Бывают случаи, когда необходимо дождаться окончания выполнения определенной нити (или сразу нескольких). Например, нам
необходимо в такой нити вычислить определенное значение, а потом использовать это значение. Если просто запустить поток 
и попробовать использовать это значение - оно еще не будет вычислено. Нужно сначала подождать завершения нити вычисления,
а потом уже переходить к нити с использованием. Делается это с помощью вызова метода `join()` для первой нити. Этот метод
не дает программе продолжить свое выполнение, пока не завершится выполнение нити, для которой был вызван `join()`. Пример:
```java
Integer x = 0;
Counter counter = new Counter(x);
Thread counterThread = new Thread(counter);

counterThread.start(); // вычисляем значение х
counterThread.join(); // ждем окончания вычисления

Printer printer = new Printer(x);
Thread printerThread = new Thread(printer);
printerThread.start(); // выводим значение х
```

## Сон потока (нити)
Сон (ожидание) в потоке (нити) реализовано статическим методом `Thread.sleep(millis)`, который принимает единственный 
аргумент - время в миллисекундах. Сон будет применен к нити, внутри которой метод вызван. Полезно, например, для 
регулирования внутри главной нити времени (или максимального времени) работы дочерней нити. Например:
1) Запускаем внутри главной нити дочернюю нить
2) Ждем N миллисекунд внутри главной нити
3) Завершаем работу дочерней нити (если она еще не завершилась)

## Завершение работы потока (нити)
Явного метода завершения работы для нити нет и быть не может, так как нить может завершиться только сама. Зато можно
передать ей сигнал о том, что ей пора завершаться (не путать с принудительным завершением). Лучший способ это реализовать - 
проверять в методе `run()` прерванность нити. Пока нить не прервана, то есть `!current.isInterrupted() == true`, можно 
продолжать выполнение `run()`. Пример:
```java
class Clock implements Runnable {
    public void run() {
        Thread current = Thread.currentThread();

        while (!current.isInterrupted()) {
            Thread.sleep(1000);
            System.out.println("Tik");
        }
    }
}

public static void main(String[] args) {
    Clock clock = new Clock();
    Thread clockThread = new Thread(clock);
    clockThread.start();

    Thread.sleep(10000);
    clockThread.interrupt();
    // Clock проработает 10 секунд и получит сигнал о завершении
    // тогда в методе run() цикл while завершится и сам run() тоже завершится, 
    // что и означает завершение работы нити
}
```
