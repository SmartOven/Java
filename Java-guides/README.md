# Гайд по Java
## Оглавление
1. [Архитектура проекта](https://github.com/SmartOven/Java-projects/tree/main/Java-guides#архитектура-проекта)
## Архитектура проекта
Проект на Java состоит из пакетов. Пакеты состоят из классов, а классы - из методов. Для запуска проекта необходимо иметь 
класс (например, Main) и метод main внутри него.
```java
public class Main {
    public static void main(String[] args) {
    }
}
```
Причем имя пакета - путь от **_корня программы_** к папке с классами. Например, если путь к файлу (классу) `Solution.java` - 
`\com\javarush\tasks\Solution.java`, то имя пакета - `com.javarush.tasks`.  
**Корнем программы** является папка `src`. Если есть папка `С:\...\ projectname\src\ com\javarush\tasks\`, то название 
пакета будет - `com.javarush.tasks`.  
Каждый файл в пакете должен содержать следующий код
```java
package имя-пакета;

public class Имя-класса
{

}
```
## Примитивные типы данных
+ Целые числа
  + byte (8 bit - 1 byte)
  + short (16 bit - 2 byte)
  + int (32 bit - 4 byte)
  + long (64 bit - 8 byte)
+ Числа с плавающей точкой
  + float (32 bit - 4 byte), обязательно указание 'f': 3.14f
  + double (64 bit - 8 byte)
+ Логический тип
  + bool (32 bit - 4 byte)
+ Символьный тип
  + char (16 bit - 2 byte)  
  Один и тот же символ может быть представлен как:
    + 1078 - индекс символа в таблице UTF-8
    + 'ж' - значение символа, сам символ
    + '\u0436' - шестнадцатеричная форма Unicode этого символа
## Как устроена Java
1. Все переменные в Java являются объектами (кроме примитивов, но и у них есть классы-обертки)
## Базовый синтаксис
### Переменные примитивных типов данных
Создать переменную и задать ей значение:  
`Type name = value;`, `value` указывать необязательно  
Пример:  
`int number = 12;`
### Все остальные переменные
Все переменные, которые не относятся к примитивным типам данных, являются объектами каких-либо классов и хранят в себе 
ссылку на этот объект. Примеры: массив, `String`.  
При этом не стоит забывать, что у каждого **_примитива_** есть **_класс-обертка_**. То есть, есть возможность создать 
переменную, которая также будет хранить ссылку на объект, но сам объект по сути будет примитивом. Полезно тогда, когда 
надо передать в другую область видимости именно ссылку на объект, а не значение примитива. То есть, когда надо изменять 
конкретный объект, а не создавать новый с тем же значением.
#### Константы
Для объявления константы используется ключевое слово `final`.  
Оно также используется для методов и классов. `final`-метод нельзя переопределить, а от `final`-класса нельзя наследоваться
#### Ключевое слово var
`var` позволяет не указывать явно тип данных создаваемой переменной, когда это **_очевидно_**. Уточним: очевидно это 
должно быть компилятору (только если переменной сразу же присваивается значение). Применимо в следующих случаях:
1. При создании нового экземпляра класса  
```java
var theLongestNameYouCanEverImagine = new TheLongestNameYouCanEverImagine();
```
2. В заголовке цикла
```java
for (var i = 1; i < 10; i++){
    //здесь что-то интересное происходит
}
var a = 2; // тип переменной a — int 
var b = 2L; // тип переменной b — long 
var c = 2F; // тип переменной c — float 
var d = 2D; // тип переменной d — double 
var e = (short) 2; //тип переменной e — short
```
Подробнее про `var` - [ссылка на статью](https://skillbox.ru/media/base/klyuchevoe-slovo-var-v-java/)
### Условные операторы
```java
if (statement) {
    do
}
```
### Циклы
В Java есть несколько видов циклов:
#### `while`
```java
while (expression) {
     statement(s)
} 
```
#### `do..while`
```java
do {
     statement(s)
} while (expression);
```
#### `for`
```java
for (initialization; termination; increment) {
    statement(s)
}
```
Здесь:  
+ `initialization` — выражение, которое инициализирует выполнение цикла. Исполняется только раз в начале цикла.  
+ `termination` — `boolean` выражение, которое регулирует окончание выполнения цикла. Цикл прервется, когда оно станет `false`.  
+ `increment` — выражение, которое исполняется после каждой итерации цикла.
#### `for each..`
```java
for (Type var : vars) {
    statement(s)
}
```
Здесь:
+ `vars` - итерируемый объект
+ `Type var` - переменная, в которую будет записываться каждый объект, входящий в `vars`.  
При этом `Type` должен совпадать с типом данных объекта `vars`
### Пользовательский ввод и вывод в консоль
Ввод данных из консоли происходит через `System.in`, а вывод - через `System.out`
Работа с вводом данных в Java организована через класс `Scanner`, находящийся в `java.util.Scanner`
#### Создание сканнера
```java
import java.util.Scanner

Scanner scanner_name = new Scanner(data_source)

// Сканнер нужно обязательно закрывать после окончания работы с ним (аналогично файлу)
scan.close();
```
Источником данных (`data_source`) может быть не только консоль (`System.in`), но и, например, строка.
### Задать разделитель для вводимых данных
```java
scanner.useDelimiter("string")
```
Метод принимает один аргумент типа `String` - по этой строке ввод будет разделяться на вводимые объекты  
Также есть возможность передавать не простую строку, а [паттерн](https://www.javatpoint.com/post/java-scanner-usedelimiter-method#:~:text=The%20useDelimiter()%20is%20a,Scanner%20useDelimiter(Pattern%20pattern)%20Method)
#### Использование сканнера
+ `scanner.nextLine()` - считывает строку целиком  
Аналогичные функции есть для следующих классов: `Int`, `Byte`, `Short`, `Long`, `Float`, `Double`
+ `scanner.hasNext()` - - проверяет, есть ли дальше на вводе хоть что-нибудь
+ `scanner.hasNextLine()` - проверяет, есть ли дальше на вводе строка данных  
Аналогичные функции есть для следующих классов: `Int`, `Byte`, `Short`, `Long`, `Float`, `Double`
### Массивы
#### Создание массива
`Type[] name = new Type[size];`, где `type` - тип данных или класс  
Пример:  
```java
int[] a = new int[10];
int n = 100;
int[] b = new int[n];
int[] c = { 0, 10, -2 };
```

При присвоении новому массиву значения старого - на самом деле будет скопирован указатель на место в памяти, а не сама память.  
Пример:
```java
int[] a = new int[10];
a[2] = 4;
a[7] = 9;
int[] b = a;
```
Что происходит? Выделяется память под `10` элементов типа `int` (`new int[10]`), указатель на выделенную память 
записывается в переменную `a`, а затем создается переменная `b`, в которую также записывается указатель (`int[] b = a;`)

#### Свойства массива
`array.length` - размер массива
#### "Неровные массивы"
При создании двумерного массива необязательно указывать вторую размерность. Тогда будет создан лишь массив массивов, 
без выделения памяти заранее. Пример:
```java
int[][] matrix = new int[2][];
matrix[0] = new int[10];
matrix[1] = new int[50];
```
Получился двумерный массив (список списков), у которого первая строка (первый элемент списка списков) имеет длину 10, 
а вторая - 50.
#### Вывод массива
Массивы можно выводить как в C++
```java
int[] array = {1, 2, 3};
for (int i = 0; i < n; i++) {
    System.out.print(array[i]);
    System.out.print(' ');
}
System.out.print('\n');

// 1 2 3 \n
```
Но также их можно выводить как списки в Python - с помощью `Arrays.toString()`
```java
int[] array = new int[n];
String array_out = Arrays.toString(array);  // "[1, 2, 3]"
System.out.println(array_out);

// [1, 2, 3]\n
```
Чтобы выводить в таком виде многомерные массивы - используйте `Arrays.deepToString()`
```java
Integer[] array = {1, 2, 3};
String str = Arrays.deepToString(array);  // "[1, 2, 3]"

int[][] array = { {1, 1}, {2, 2}, {3, 3} };
String str = Arrays.deepToString(array);  // "[[1, 1], [2, 2], [3, 3]]"

int[][][] array = { {{1, 2, 3}, {1}}, {{}} };
String str = Arrays.deepToString(array);  // "[[[1, 2, 3], [1]], [[]]]"
```
#### Сравнение массивов
Одномерных
```java
int[] x1 = {1, 2, 3};
int[] x2 = {1, 2, 3};
boolean a = (x1 == x2);             // false (ссылки не равны)
boolean b = (x1.equals(x2));        // false (ссылки не равны)
boolean c = Arrays.equals(x1, x2);  // true  (содержимое массивов равно)
```
Многомерных
```java
int[][] x1 = {{1, 2, 3}, {4, 5, 6}};
int[][] x2 = {{1, 2, 3}, {4, 5, 6}};
boolean a = x1.equals(x2);              // false (ссылки не равны)
boolean b = Arrays.equals(x1, x2);      // false (ссылки не равны)
boolean c = Arrays.deepEquals(x1, x2);  // true (содержимое массивов равно)
```
#### Заполнение массива
```java
int[] x = new int[100];
// Заполняет "x" целиком числом 999
Arrays.fill(x, 999);
// x = [999, 999, 999, ... , 999]

// indexes: 0  1  2  3  4  5  6  7  8  9
int[] y = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
// Заполняет "y" в диапазоне [3, 7) числом 999
Arrays.fill(y, 3, 7, 999);
// indexes: 0  1  2  3    4    5    6    7  8  9
//     y = [1, 2, 3, 999, 999, 999, 999, 8, 9, 10]
```
#### Копирование массива
Например, нам нужен массив побольше (или поменьше), но с теми же значениями
```java
int[] x = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // x.length = 10

int[] x2 = Arrays.copyOf(x, 5);          // "[1, 2, 3, 4, 5]"
int[] x3 = Arrays.copyOf(x, 15);         // "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0, 0, 0]"
int[] x4 = Arrays.copyOfRange(x, 5, 10); // "[6, 7, 8, 9, 10]"
int[] x5 = Arrays.copyOfRange(x, 5, 15); // "[6, 7, 8, 9, 10, 0, 0, 0, 0, 0]"
```
#### Сортировка массива
```java
int[] x = {11, -2, 3, 0, 999, -20, 8, -20, 99, -20};

Arrays.sort(x);       // "[-20, -20, -20, -2, 0, 3, 8, 11, 99, 999]"
Arrays.sort(x, 4, 8); // "[11, -2, 3, 0, -20, -20, 8, 999, 99, -20]"
```
### Строки
За строки в Java отвечает класс String. В переменной этого класса хранится адрес на выделенную память под строку 
(аналогично массиву). Объект String является неизменяемым (_immutable_). То есть при любых операциях над строкой, 
которые изменяют эту строку, фактически будет создаваться **новая строка**.
#### Создание новой строки
```java
String str1 = "";
String str2 = "aghjfoljsu";
String str3 = new String(char[]{'a', 'g', 'h', 'j', 'f', 'o', 'l, 'j', 's', 'u'});
```
#### Полезные методы строк
1. `int length()` - Возвращает количество символов в строке.
2. `boolean isEmpty()` - Проверяет, что строка == пустая строка.
3. `boolean isBlank()` - Проверяет, что в строке — только whitespace-символы: пробел, tab, enter и т.п.
4. `char charAt(int index)` - Возвращает символ, который стоит на index-позиции в строке.
5. `int indexOf(char ch)` - Возвращает индекс символа `ch` в строке (необязательно его первое вхождение), если его  
вообще нет в строке - возвращает `-1`.
6. `char[] toCharArray()` - Возвращает массив символов (копию), из которых состоит строка.
7. `String[] split(String regex)` - разделяет строку по разделителю `regex` на массив подстрок.
8. `String join(CharSequence delimiter, elements)` - собирает строку из массива подстрок `elements`, добавляя между ними 
строки-разделители `CharSequence`.
9. `String intern()` - Помещает строку в пул `StringPool`.
10. `replace(char oldChar, char newChar)` - заменяет все `oldChar` в строке на `newChar`
#### Сравнение строк
1. `boolean equals(String str)` - Строки считаются равными, если все их символы совпадают.
2. `boolean equalsIgnoreCase(String str)` - Сравнивает строки, игнорируя регистр (размер) букв
3. `int compareTo(String str)` - Сравнивает строки лексикографически. Возвращает 0, если строки равны. Число меньше нуля, 
если текущая строка меньше строки-параметра. Число больше нуля, если текущая строка больше строки-параметра. Аналогичен 
`strcmp` из С
4. `int compareToIgnoreCase(String str)` - то же, что и предыдущий, но без учета регистра
5. `boolean regionMatches(int toffset, String str, int offset, int len)` - Сравнивает части строк
#### Поиск префикса и суффикса
1. `boolean startsWith(String prefix)` - Проверяет, что текущая строка начинается со строки `prefix`
2. `boolean endsWith(String suffix)` - Проверяет, что текущая строка заканчивается на строку `suffix`
#### Поиск подстрок
1. `int indexOf(String str)` - Ищет строку str в текущей строке. Возвращает индекс первого символа встретившийся строки
2. `int indexOf(String str, int index)` - Ищет строку str в текущей строке, пропустив index первых символов. Возвращает 
индекс найденного вхождения
3. `int lastIndexOf(String str)` - Ищет строку str в текущей строке с конца. Возвращает индекс первого вхождения
4. `int lastIndexOf(String str, int index)` - Ищет строку str в текущей строке с конца, пропустив index первых символов
#### Регулярные выражения
`boolean matches(String regex)` - Проверяет, что текущая строка совпадает с шаблоном, заданным регулярным выражением
### Функции
В Java "функции" не могут существовать отдельно от классов - только внутри них. То есть функций в Java нет - есть только
методы. По большей части не отличаются от методов класса в C++
#### Модификаторы прав доступа
------------------------------ Доступ из...  
Модификаторы -------- Любого класса --- Класса-наследника --- Своего пакета --- Своего класса  
`public` ------------------ Есть ----------------- Есть ------------------------ Есть ---------------- Есть  
`protected` -------------- Нет ------------------ Есть ------------------------ Есть ---------------- Есть  
без модификатора ---- Нет ------------------ Нет -------------------------- Есть ---------------- Есть  
`private` ----------------- Нет ------------------ Нет -------------------------- Нет ----------------- Есть  

В отличие от С++, в Java существует еще один модификатор доступа "без модификатора" или "модификатор по умолчанию":  
1. Модификатор `private` - доступ к методу есть только внутри класса этого метода.  
2. Модификатор по умолчанию - доступ к методу есть у всего пакета (но не за его пределами).  
3. Модификатор `protected` - доступ к методу есть у классов-наследников и у всего пакета (но не за его пределами).
4. Модификатор `public` - доступ к методу есть везде и у всех
#### Static или не static
`static` - модификатор, означающий привязку метода (или переменной) к классу.  
В случае с переменной - статическая переменная будет общей для всего класса, а нестатическая - будет принадлежать 
конкретному объекту. Например, у каждого яблока переменная `weight` отличается по значению (не `static`), а переменная 
`shape` - для всех одинаковая (`static`).  
В случае с методом - статический метод принадлежит классу (то есть, может обращаться только к статическим переменным - 
переменным класса), а нестатический - к любым. Таким образом, статический метод можно вызвать не создавая объект класса.
#### Исключения
### Классы
#### Создание класса
Базовый синтаксис объявления класса также обязан содержать информацию о пакете, в котором создан класс
```java
package имя-пакета;

public class Имя-класса {
}
```

#### Наследование
Наследование осуществляется через ключевое слово `extends`
```java
public class Human extends Terran {
}
```
#### Импорт классов
### Псевдослучайные числа в Java
Случайные числа можно получать из метода `Math.random()` - он возвращает случайное `double` в диапазоне `[0; 1)`.  
Получение случайных целых чисел в диапазоне `[x; y]` и `[x; y)`:
```java
public static int generateNumber1(int x, int y) {
    return (int) (Math.random() * (y - x + 1) + x);
}  // [x; y]

public static int generateNumber2(int x, int y) {
    return (int) (Math.random() * (y - x) + x);
}  // [x; y)
```
Также в Java есть специальный класс `Random`, объекты которого хранят в себе последовательности псевдослучайных чисел.  
Примеры:
```java
Random r = new Random();      // создаем объект класса Random
float f = r.nextFloat();      // получаем случайный float в диапазоне [0; 1)
double d = r.nextDouble();    // получаем случайный double в диапазоне [0; 1)
int i = r.nextInt(6) + 1;     // получаем случайный int в диапазоне [0; 6) (=> [0; 5]), прибавляем 1 (=> [1; 6])
int i = r.nextInt();          // int в диапазоне всех возможных значений int
long l = r.nextLong();        // аналогично предыдущему, только с long
boolean b = r.nextBoolean();  // аналогично предыдущему, только с boolean (собственно, либо true, либо false)

byte[] buffer = new byte[1000];
nextBytes(buffer);            // заполняет переданный массив байтов случайными данными


double g = r.nextGaussian();  // аналогично r.nextDouble(), только случайность неравномерна - она распределяется
                              // по графику нормального распределения. То есть чаще будут выпадать числа
                              // близкие к 0.50, а числа, близкие к 0.00 и 0.99 почти не будут встречаться
```
### Другое
#### Паузы в программе
1. Либо `Thread.sleep(миллисекунды, наносекунды);`  
2. Либо `TimeUnit.DAYS.sleep(число);`.  
Варианты функции: `NANOSECONDS`, `MICROSECONDS`, `MILLISECONDS`, `SECONDS`, `MINUTES`, `HOURS`, `DAYS`
#### Побитовые операции
1. `&` - AND
2. `|` - OR
3. `^` - XOR
4. `~` - NOT
5. `<<` - побитовый сдвиг влево (умножение на 2)
6. `>>` - побитовый сдвиг вправо (деление на 2, не меняет знак числа)
7. `>>>` - тоже побитовый сдвиг вправо, но число становится положительным, если оно было отрицательным
#### Работа с флагами
Это способ хранения большого количества `true`/`false` значений в одном целом числе. Способ основан на том, что эти
"переменные" - это биты числа по порядку. Например, `int` может хранить 32 таких "флага", а `long` - 64.  
Основные операции:
1. **Установка флага**  
Чтобы установить определенный (i-ый) бит в `1` - нужно выполнить **_побитовое ИЛИ_** между исходным числом и числом, 
состоящим только из одной 1 в i-ом разряде:  
`0b00001010 | 0b00000100 = 0b00001110` => `a | (1 << i)`
2. **Сброс флага**  
Чтобы сбросить определенный (i-ый) бит в `0` - нужно выполнить **_побитовое И_** между исходным числом и числом, 
состоящим только из одного 0 в i-ом разряде:  
`0b00001010 & 0b11111101 = 0b00001000` => `a & ~(1 << i)`
3. **Проверка флага**  
Чтобы проверить i-ый флаг - нужно сравнить исходное число с результатом установки данного флага: если они совпадают, то 
флаг уже был установлен, а если не совпадают - флаг не был установлен.  
`if ( (0b00001010 & 0b00001000) == 0b00001000 )` => `(a & (1 << i)) == (1 << i)`
#### Простое шифрование
Самый простой способ зашифровать числовые данные
1. Придумываем число (пароль)
2. Применяем XOR (исключающее ИЛИ) между числом и "паролем" => получаем "зашифрованное" число  
`результат = оригинальное число ^ пароль;`
3. Передаем получателю и "зашифрованное" число, и "пароль"
4. Получатель применяет XOR с "паролем" к "зашифрованному" числу => получает исходное число  
`оригинальное число = результат ^ пароль;`
#### Другие системы счисления
Для задания целого числа в восьмеричной системе счисления - нужно написать `0` перед числом
```java
int x = 015;   // = 13
int x = 025;   // = 21
int x = 0123;  // = 83
```
Для задания целого числа в двоичной системе счисления - нужно написать `0b` перед числом
```java
int x = 0b100;         // = 4
int x = 0b1111;        // = 15
int x = 0b1111000111;  // = 967
```
Для задания целого числа в шестнадцатеричной системе счисления - нужно написать `0x` перед числом
```java
int x = 0x1;    // = 1
int x = 0xF;    // = 15
int x = 0x1F;   // = 31
int x = 0xFFF;  // = 4095
```